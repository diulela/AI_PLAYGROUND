# 需求清单编写方法论

> 本文档定义「如何将竞品分析产出物转化为可追踪的需求清单」的思维流程。  
> 它是 [00-竞品截图分析方法论](./00-竞品截图分析方法论.md) 的下游衔接——前者解决"如何从截图到设计规格"，本文档解决"如何从设计规格到可执行需求"。

---

## 一、适用场景

### 什么时候用这套方法

- 你已经完成了竞品截图分析，手上有一批页面规格文档
- 你需要把分析结论转化为团队可执行、可追踪的需求清单
- 需求清单需要长期维护、跨版本迭代，而不是写完就扔

### 输入

| 输入项 | 说明 |
|-------|------|
| 页面规格文档 | 每个页面的布局、组件、交互、文案详情 |
| 全局设计规范 | 共享的流程图、设计语言、组件定义 |
| 竞品分析笔记 | 设计亮点、待改进点、我方产品策略 |

### 输出

| 输出物 | 受众 | 作用 |
|-------|------|------|
| 需求清单（活文档） | PM + 设计 + 开发 + QA | 追踪开发进度的唯一来源 |
| 本方法论文档 | 团队全员 | 统一需求编写标准，确保可复用 |

---

## 二、核心思维：需求清单不是分析报告

### 最常见的错误

很多人把竞品分析的"逐屏分析"直接当作需求清单。这是错误的。

| | 竞品分析报告 | 需求清单 |
|---|------------|---------|
| **本质** | 描述"别人做了什么" | 定义"我们要做什么" |
| **生命周期** | 写完即归档，偶尔回顾 | 持续更新，直到产品下线 |
| **阅读频率** | 评审会看一次 | 每天的站会、每周的迭代会都要看 |
| **关注点** | 全面性（覆盖所有细节） | 可执行性（每条都能被指派和验证） |
| **组织方式** | 按页面/截图顺序 | 按功能模块/优先级/版本 |

**核心原则：需求清单是"活文档"，不是"交付物"。**

### 关注点分离

一份好的需求体系应该把不同性质的内容分开存放：

```
竞品分析产出（归档，用于决策参考）
  ├── 逐屏分析        → 归入「页面规格文档」
  ├── 设计亮点        → 归入「需求清单附录」
  └── 视觉参数        → 归入「全局设计规范」

需求清单（活文档，用于日常追踪）
  ├── 需求总表        → 速查进度
  ├── 需求详情        → 执行依据
  └── 变更日志        → 追溯历史
```

**判断标准**：如果某段内容在下个月还会有人打开它、修改它，它就属于"活文档"（需求清单）。如果它写完后只会偶尔回顾，它就应该归档。

---

## 三、需求清单编写的五步法

### 总览

```
第一步「提取」→ 第二步「去重合并」→ 第三步「补全」→ 第四步「结构化」→ 第五步「质检」
```

---

### 第一步：提取 — 从页面规格中提取原始需求点

**做什么**：遍历每一份页面规格文档，把其中的每一个"用户可感知的功能"提取为一条需求。

**判断标准**：什么算一条独立需求？

| 算 | 不算 |
|-----|------|
| 用户可感知的独立功能 | 纯视觉/样式细节 |
| 可以被独立开发和测试 | 某个功能的内部实现步骤 |
| 有明确的"做了"和"没做"的区分 | 需要和其他功能捆绑才有意义的碎片 |

**示例**：
- "密码设置与实时校验" → 算一条需求（独立功能，可独立测试）
- "密码输入框右侧有眼睛图标" → 不算独立需求（是密码设置需求的一个验收标准）
- "密码规则4项实时校验" → 不算独立需求（是密码设置需求的一个验收标准）

**颗粒度原则**：一条需求应该能在 1-5 天内完成设计+开发+测试。太粗要拆分，太细要合并。

### 第二步：去重合并 — 消除冗余

**做什么**：把第一步提取的原始需求点进行去重和合并。

**常见需要合并的情况**：

| 情况 | 示例 | 处理方式 |
|------|------|---------|
| 同一功能出现在多个页面 | "导航栏返回按钮"在 6 个页面都有 | 不单独建需求，归入全局组件 |
| 强关联的小功能 | "密码输入"+"密码校验"+"密码确认" | 合并为"密码设置与校验"一条需求 |
| 竞品分析和补充需求重复 | 功能清单和补充需求都提到同一个功能 | 合并为一条，标注来源 |

**关键**：每个功能只在需求清单中出现一次。

### 第三步：补全 — 填充竞品截图中看不到的需求

**做什么**：竞品截图只展示了"阳光路径"。你需要主动补全：

1. **行业通用功能** — 竞品一定有但截图没覆盖的（如助记词验证环节）
2. **异常处理** — 如果错误/异常处理本身足够复杂，值得作为独立需求
3. **安全增强** — 截屏检测、生物识别等安全功能
4. **体验优化** — 竞品没做但你认为应该做的改进

**每条补全需求必须标注来源**：
- `竞品参考` — 直接从截图中看到的
- `行业通用` — 截图没展示但行业标配
- `自主创新` — 我方团队主动提出的改进

### 第四步：结构化 — 把需求组织成可追踪的格式

这一步是需求清单质量的核心。

#### 4.1 按功能模块分组

不要按页面分组，而要按**功能模块**分组。

| 按页面分组（不推荐） | 按模块分组（推荐） |
|------------------|----------------|
| 欢迎页的需求 | 欢迎引导模块 |
| 创建钱包页的需求 | 钱包创建模块 |
| ... | 助记词备份模块 |

**原因**：一个功能可能跨多个页面（如"密码"在创建页设置、在验证弹窗使用）。按模块分组才能看到功能的完整闭环。

#### 4.2 建立需求总表

需求总表是"速查表"，让任何人打开文档就能在 10 秒内看到全局进度。

必须包含的列：

| 列 | 作用 |
|-----|------|
| ID | 唯一标识，永不改变 |
| 需求名称 | 一眼看出是什么功能 |
| 优先级 | P0/P1/P2，决定做不做、先做后做 |
| 状态 | Backlog/Design/Dev/QA/Done，追踪进度 |
| 目标版本 | 计划在哪个版本实现 |
| 负责人 | 谁在负责 |

#### 4.3 编写需求详情

每条需求都要有独立的详情块，包含：

**必填字段**：

| 字段 | 说明 |
|------|------|
| 用户故事 | "作为[角色]，我希望[行为]，以便[价值]" |
| 验收标准 | **必须是 checklist 格式**，QA 可逐项验证 |
| 依赖 | 哪些需求是前置条件 |
| 设计规格链接 | 链接到对应的页面规格文档 |
| 来源 | 竞品参考/行业通用/自主创新 |

**为什么验收标准必须是 checklist？**

对比：

```
❌ 差的验收标准：
"展示完整协议文本，提供同意按钮，未同意前不可继续"

✅ 好的验收标准：
- [ ] 展示完整协议文本，支持滚动阅读
- [ ] 导航栏显示"用户协议"标题 + 返回按钮 + 外链图标
- [ ] 点击外链图标可在系统浏览器中查看完整协议
- [ ] 底部提供"同意本条款，下次不再提示"按钮
- [ ] 未点击同意前，不可进入创建钱包流程
- [ ] 点击同意后，Push 进入创建 HD 钱包页
```

差异在于：**差的验收标准需要理解才能验证，好的验收标准只需要逐项打勾**。QA 拿到好的验收标准，不需要找 PM 确认"展示完整协议文本是什么意思"。

#### 4.4 建立依赖关系

需求之间有先后顺序。明确的依赖关系帮助：
- 开发排期时知道什么能并行、什么必须串行
- 某条需求 delay 时，能快速评估影响范围

```
REQ-001（创建钱包入口）
  └── REQ-005（用户协议）
      └── REQ-007（密码设置）
          └── REQ-008（创建成功）
              └── REQ-012（备份引导）
                  └── REQ-013（身份验证）→ 依赖 REQ-007（需要密码）
                      └── REQ-014（安全警告）
                          └── REQ-015（助记词展示）
                              └── REQ-016（确认备份）
                                  └── REQ-017（助记词验证）
```

### 第五步：质检 — 验证需求清单的完整性和可用性

#### 完整性自检

- [ ] 每个页面规格文档中的功能都对应了至少一条需求
- [ ] 所有补充需求（行业通用、自主创新）都已整合到主需求表中
- [ ] 没有"孤立需求"——每条需求要么是流程起点，要么有明确依赖
- [ ] P0 需求构成完整的用户流程闭环（从入口到完成）

#### 可用性自检

- [ ] 任何团队成员打开总表，10 秒内能看到全局进度
- [ ] 点击任何一条需求，能看到完整的用户故事和验收标准
- [ ] QA 可以仅凭验收标准（不看截图）写出测试用例
- [ ] 开发可以通过"设计规格链接"直接找到对应的页面规格文档
- [ ] 需求之间的依赖关系清晰，可以据此排开发计划

#### 可维护性自检

- [ ] 需求编号使用固定格式（如 `REQ-XXX`），不会因为插入新需求而打乱编号
- [ ] 有变更日志，每次修改都有记录
- [ ] 竞品分析内容已归档，不影响需求追踪的日常使用

---

## 四、常见陷阱与规避

### 陷阱 1：需求清单 = 竞品功能列表

**症状**：需求清单就是"TronLink 有什么我们就做什么"的复制。

**问题**：
- 缺少自主创新和差异化
- 忽略了竞品做得不好的地方
- 没有根据自身产品策略做取舍

**规避**：每条需求标注"来源"字段。如果所有需求的来源都是"竞品参考"，说明你只在抄，没有在思考。

### 陷阱 2：需求颗粒度不均匀

**症状**：有的需求是"创建钱包"（太粗），有的是"输入框右侧有清除按钮"（太细）。

**问题**：
- 太粗的需求无法准确评估工作量
- 太细的需求让清单臃肿、难以管理

**规避**：每条需求应对应 1-5 天的工作量。超过 5 天就拆，不到半天就合并到上级需求的验收标准里。

### 陷阱 3：验收标准不可测试

**症状**："用户体验好""页面美观""安全性强"。

**问题**：主观描述无法验收，不同人有不同理解。

**规避**：每条验收标准都要能被转化为一个"是/否"判断。如果不能，就继续细化，直到可以。

### 陷阱 4：只有 P0 没有 P1/P2

**症状**：团队把所有需求都标为 P0，认为"都很重要"。

**问题**：如果所有需求都是最高优先级，那就等于没有优先级。

**规避**：P0 应只包含"没有这个功能产品就不能用"的需求。使用以下判断：
- P0：去掉它产品流程断裂
- P1：去掉它产品能用但体验差
- P2：去掉它产品正常使用，加上它有差异化优势

### 陷阱 5：写完就扔，不持续维护

**症状**：需求清单写完后再没人打开，开发用口头沟通或即时消息确认需求。

**问题**：口头沟通没有记录，导致需求理解不一致、变更不可追溯。

**规避**：
- 每日站会用需求总表同步进度（更新状态列）
- 需求变更必须更新文档并记录变更日志
- 定期检查需求清单与实际开发的一致性

---

## 五、需求清单模板

### 文档头模板

```markdown
# [产品名] — 需求清单

> 分析模块：**[功能模块名称]**  
> 文档版本：v1.0  
> 最后更新：YYYY-MM-DD

## 文档说明
### 关联文档
（链接到设计规格文档）
### 字段说明
（定义每个字段的含义）
### 变更日志
| 版本 | 日期 | 变更内容 | 变更人 |
```

### 需求总表模板

```markdown
## 需求总表

### 模块一：[模块名]

| ID | 需求名称 | 优先级 | 状态 | 目标版本 | 负责人 |
|----|---------|-------|------|---------|-------|
| REQ-001 | [需求名] | P0 | Backlog | v1.0 | 张三 |
```

### 需求详情模板

```markdown
### REQ-XXX

**[需求名称]**

| 字段 | 内容 |
|------|------|
| 模块 | [所属模块] |
| 优先级 | P0/P1/P2 |
| 来源 | 竞品参考 / 行业通用 / 自主创新 |
| 依赖 | REQ-YYY, REQ-ZZZ |
| 设计规格 | [页面名](./docs/XX-页面名.md) |

**用户故事**：作为[角色]，我希望[行为]，以便[价值]。

**验收标准**：
- [ ] 具体的、可测试的条件 1
- [ ] 具体的、可测试的条件 2
- [ ] 具体的、可测试的条件 3
```

---

## 六、与上下游的关系

```
[竞品截图] 
    ↓ 四层分析法（00-竞品截图分析方法论.md）
[页面规格文档 + 全局设计规范]
    ↓ 五步编写法（本文档）
[需求清单]
    ↓ 
[设计稿] → [开发] → [测试] → [上线]
```

- **上游**：竞品截图分析方法论产出的页面规格文档是本方法论的输入
- **下游**：需求清单是设计师出设计稿、开发排期、QA 写测试用例的依据
- **反馈环**：开发和测试过程中发现的新需求或变更，回到需求清单更新

---

*本方法论版本：v1.0 | 创建日期：2026-02-10*
